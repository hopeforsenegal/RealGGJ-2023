/**
 * Odin binding generator from C header data.
 */

package bindgen

import "core:os"
import "core:strings"
import "core:fmt"
import "core:runtime"

GeneratorOptions :: struct {
    // Variable
    variableCase : Case,

    // Defines
    definePrefixes : []string,
    defineTransparentPrefixes : []string,
    definePostfixes : []string,
    defineTransparentPostfixes : []string,
    defineCase : Case,

    // Pseudo-types
    pseudoTypePrefixes : []string,
    pseudoTypeTransparentPrefixes : []string,
    pseudoTypePostfixes : []string,
    pseudoTypeTransparentPostfixes : []string,
    pseudoTypeCase : Case,

    // Functions
    functionPrefixes : []string,
    functionTransparentPrefixes : []string,
    functionPostfixes : []string,
    functionTransparentPostfixes : []string,
    functionCase : Case,

    // Enum values
    enumValuePrefixes : []string,
    enumValueTransparentPrefixes : []string,
    enumValuePostfixes : []string,
    enumValueTransparentPostfixes : []string,
    enumValueCase : Case,
    enumValueNameRemove : bool,
    enumValueNameRemovePostfixes : []string,

    odin_includes: []string,
    odin_using_includes: []string,
    typeReplacements: map[string]string,
    extra_type_string_lines: []string,
    removeFunctions: []string,

    parserOptions : ParserOptions,
}

GeneratorData :: struct {
    handle : os.Handle,
    nodes : Nodes,

    // References
    options : ^GeneratorOptions,
}

Enum_Args :: [dynamic]string;
Enum_Args_Map :: map[string]Enum_Args;

generate :: proc(
    packageName : string,
    foreignLibrary : string,
    outputFile : string,
    typesFile : string,
    bridgeFile : string,
    headerFiles : []string,
    options_: GeneratorOptions,
    enum_args_map : Enum_Args_Map,
) -> bool {
    options := options_;

    data : GeneratorData;
    data.options = &options;

    options.parserOptions.enum_args_map = enum_args_map;

    // Parsing header files
    for headerFile in headerFiles {
        bytes, ok := os.read_entire_file(headerFile);
        if !ok {
            fmt.eprint("[bindgen] Unable to read file ", headerFile, "\n");
            return false;
        }

        // We fuse the SOAs
        headerNodes := parse(bytes, options.parserOptions);
        merge_generic_nodes(&data.nodes.defines, &headerNodes.defines);
        merge_generic_nodes(&data.nodes.enumDefinitions, &headerNodes.enumDefinitions);
        merge_generic_nodes(&data.nodes.unionDefinitions, &headerNodes.unionDefinitions);
        merge_forward_declared_nodes(&data.nodes.structDefinitions, &headerNodes.structDefinitions);
        merge_generic_nodes(&data.nodes.functionDeclarations, &headerNodes.functionDeclarations);
        merge_generic_nodes(&data.nodes.typedefs, &headerNodes.typedefs);
    }

    // Outputing odin "types" file
    {
        errno : os.Errno;
        data.handle, errno = os.open(typesFile, os.O_WRONLY | os.O_CREATE | os.O_TRUNC);
        if errno != 0 {
            fmt.eprint("[bindgen] Unable to write to output file ", typesFile, " (", errno ,")\n");
            return false;
        }
        defer os.close(data.handle);

        fmt.fprintln(data.handle, "//");
        fmt.fprintln(data.handle, "// generated by bindgen (https://github.com/Breush/odin-binding-generator)");
        fmt.fprintln(data.handle, "//");
        fmt.fprint(data.handle, "\n");

        fmt.fprint(data.handle, "package ", packageName, "_types\n");
        fmt.fprint(data.handle, "\n");
        fmt.fprint(data.handle, "import _c \"core:c\"\n");
        fmt.fprint(data.handle, "\n");

        for include in options.odin_includes {
            fmt.fprintf(data.handle, "import \"%s\"\n", include);
        }
        for include in options.odin_using_includes {
            fmt.fprintf(data.handle, "import \"../%s\"\n", include);
        }

        // Exporting
        export_defines(&data);
        export_typedefs(&data);
        export_enums(&data);
        export_structs(&data);
        export_unions(&data);

        fmt.fprint(data.handle, packageName, "_Funcs :: struct {\n");
        export_functions(&data, Export_Functions_Mode.Pointer_In_Struct);
        fmt.fprint(data.handle, "}\n\n");

    }

    // Outputing odin "bindings" file
    {
        errno : os.Errno;
        data.handle, errno = os.open(outputFile, os.O_WRONLY | os.O_CREATE | os.O_TRUNC);
        if errno != 0 {
            fmt.eprint("[bindgen] Unable to write to output file ", outputFile, " (", errno ,")\n");
            return false;
        }
        defer os.close(data.handle);

        builder : = strings.make_builder();
        /*
        removed includes from here because they were going unused
        for include in options.odin_includes {
            fmt.sbprintf(&builder, "import \"%s\"\n", include);
        }
        */
        for include in options.odin_using_includes {
            fmt.sbprintf(&builder, "import \"%s\"\n", include);
        }
        additional_includes_string := strings.to_string(builder);

        foreignLibrarySimple := fmt.tprintf("%s_native", simplify_library_name(foreignLibrary));
        assert(len(foreignLibrarySimple) > 0, fmt.tprint("simplified a foreign library name to a zero-length string: ", foreignLibrary));

        fmt.fprintf(data.handle, `
//
// THIS FILE WAS AUTOGENERATED
//

package %s_bindings

foreign import %s "%s"

import _c "core:c"
%s

import %s_types "./types"

%s_Funcs :: %s_types.%s_Funcs;

`, packageName, foreignLibrarySimple, foreignLibrary, additional_includes_string, packageName, packageName, packageName, packageName);

        reexport_types(data, packageName);

        fmt.fprintf(data.handle, `
get_function_pointers :: proc(funcs: ^%s_types.%s_Funcs) {{
`, packageName, packageName);

        // assign incoming func pointers to struct
        for node in data.nodes.functionDeclarations {
            if should_skip_function_node(&data, node) do continue;
            function_name := clean_function_name(node.name, data.options);
            fmt.fprintf(data.handle, "    funcs.%s = %s;\n", function_name, function_name);
        }

        fmt.fprint(data.handle, "}\n\n");

        // Foreign block for functions
        fmt.fprint(data.handle, "@(default_calling_convention=\"c\")\n");
        fmt.fprint(data.handle, "foreign ", foreignLibrarySimple, " {\n");
        fmt.fprint(data.handle, "\n");

        export_functions(&data);

        fmt.fprint(data.handle, "}\n");
    }

    // bridge "plugin" file
    {
        errno : os.Errno;
        data.handle, errno = os.open(bridgeFile, os.O_WRONLY | os.O_CREATE | os.O_TRUNC);
        if errno != 0 {
            fmt.eprint("[bindgen] Unable to write to output file ", bridgeFile, " (", errno ,")\n");
            return false;
        }
        defer os.close(data.handle);

        fmt.fprintf(data.handle, `
package %s

import raylib_types "../types"

%s_Funcs :: raylib_types.%s_Funcs;

`, packageName, packageName, packageName);

        reexport_types(data, "raylib");

        fmt.fprintf(data.handle, `

import _c "core:c"

bridge_init :: proc(funcs: ^%s_Funcs) {{
`, packageName);

        count := 0;

        // assign incoming struct function pointers to package level function pointers 
        for node in data.nodes.functionDeclarations {
            if should_skip_function_node(&data, node) do continue;
            function_name := clean_function_name(node.name, data.options);
            if count == 0 {
                fmt.fprint(data.handle, "    assert(funcs != nil);\n");
                fmt.fprintf(data.handle, "    assert(funcs.%s != nil);\n\n", function_name);
            }
            fmt.fprintf(data.handle, "    %s = funcs.%s;\n", function_name, function_name);
            count += 1;
        }

        fmt.fprintf(data.handle, `}

bridge_deinit :: proc() {{
}}

`);
        export_functions(&data, Export_Functions_Mode.Plugin_Pointers);
    }

    return true;
}

// system:foo.lib -> foo
simplify_library_name :: proc(libraryName : string) -> string {
    startOffset := 0;
    endOffset := len(libraryName);

    for c, i in libraryName {
        if startOffset == 0 && c == ':' {
            startOffset = i + 1;
        }
        else if c == '/' {
            startOffset = i + 1;
        }
        else if c == '.' {
            endOffset = i;
        }
    }

    return libraryName[startOffset:endOffset];
}

merge_generic_nodes :: proc(nodes : ^$T, headerNodes : ^T) {
    for headerNode in headerNodes {
        // Check that there are no duplicated nodes (due to forward declaration or such)
        duplicatedIndex := -1;
        for i := 0; i < len(nodes); i += 1 {
            node := nodes[i];
            if node.name == headerNode.name {
                duplicatedIndex = i;
                break;
            }
        }

        if duplicatedIndex < 0 {
            append(nodes, headerNode);
        }
    }
}

merge_forward_declared_nodes :: proc(nodes : ^$T, headerNodes : ^T) {
    for headerNode in headerNodes {
        // Check that there are no duplicated nodes (due to forward declaration or such)
        duplicatedIndex := -1;
        for i := 0; i < len(nodes); i += 1 {
            node := nodes[i];
            if node.name == headerNode.name {
                duplicatedIndex = i;
                break;
            }
        }

        if duplicatedIndex < 0 {
            append(nodes, headerNode);
        }
        else if !headerNode.forwardDeclared {
            nodes[duplicatedIndex] = headerNode;
        }
    }
}

reexport_types :: proc(data: GeneratorData, packageName: string = "") {
    fmt.fprint(data.handle, "// re-export everything from ./types for convienience\n");

    for line in data.options.extra_type_string_lines {
        fmt.fprintf(data.handle, "%s\n", line);
    }

    types_prefix := "";
    if len(packageName) > 0 {
        types_prefix = fmt.tprint(packageName, "_types.");
    }

    // defines
    for node in data.nodes.defines {
        defineName := clean_define_name(node.name, data.options);
        fmt.fprint(data.handle, defineName,
            node.is_variable ? " := " : " :: ",
            types_prefix, defineName, ";\n");
    }
    fmt.fprint(data.handle, "\n");

    // typedefs
    for node in data.nodes.typedefs {
        aliasName := clean_pseudo_type_name(node.name, data.options);
        sourceType := clean_type(node.sourceType, data.options);
        if aliasName == sourceType do continue;
        fmt.fprint(data.handle, aliasName, " :: ", types_prefix, aliasName, ";\n");
    }
    fmt.fprint(data.handle, "\n");

    // structs
    for node in data.nodes.structDefinitions {
        structName := clean_pseudo_type_name(node.name, data.options);
        fmt.fprint(data.handle, structName, " :: ", types_prefix, structName, ";\n");
    }

    // enums
    for node in data.nodes.enumDefinitions {
        enumName := clean_pseudo_type_name(node.name, data.options);

        // @Kevin Hack - don't rexport AnonymousEnumX
        anon := "AnonymousEnum"; 
        if len(enumName) > len(anon) && enumName[:len(anon)] == anon {
            continue;
        }

        fmt.fprint(data.handle, enumName, " :: ", types_prefix, enumName, ";\n");
    }
}
