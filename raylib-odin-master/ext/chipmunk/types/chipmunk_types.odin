//
// generated by bindgen (https://github.com/Breush/odin-binding-generator)
//

package chipmunk_types

import _c "core:c"


Float :: _c.double;
HashValue :: _c.uintptr_t;
CollisionId :: u32;
Bool :: _c.uchar;
DataPointer :: rawptr;
CollisionType :: _c.uintptr_t;
Group :: _c.uintptr_t;
Bitmask :: _c.uint;
Timestamp :: _c.uint;
SpatialIndexBbFunc :: #type proc();
SpatialIndexIteratorFunc :: #type proc();
SpatialIndexQueryFunc :: #type proc();
SpatialIndexSegmentQueryFunc :: #type proc();
BbTreeVelocityFunc :: #type proc();
SpatialIndexDestroyImpl :: #type proc();
SpatialIndexCountImpl :: #type proc();
SpatialIndexEachImpl :: #type proc();
SpatialIndexContainsImpl :: #type proc();
SpatialIndexInsertImpl :: #type proc();
SpatialIndexRemoveImpl :: #type proc();
SpatialIndexReindexImpl :: #type proc();
SpatialIndexReindexObjectImpl :: #type proc();
SpatialIndexReindexQueryImpl :: #type proc();
SpatialIndexQueryImpl :: #type proc();
SpatialIndexSegmentQueryImpl :: #type proc();
BodyVelocityFunc :: #type proc();
BodyPositionFunc :: #type proc();
BodyShapeIteratorFunc :: #type proc();
BodyConstraintIteratorFunc :: #type proc();
BodyArbiterIteratorFunc :: #type proc();
ConstraintPreSolveFunc :: #type proc();
ConstraintPostSolveFunc :: #type proc();
DampedSpringForceFunc :: #type proc();
DampedRotarySpringTorqueFunc :: #type proc();
CollisionBeginFunc :: #type proc();
CollisionPreSolveFunc :: #type proc();
CollisionPostSolveFunc :: #type proc();
CollisionSeparateFunc :: #type proc();
PostStepFunc :: #type proc();
SpacePointQueryFunc :: #type proc();
SpaceSegmentQueryFunc :: #type proc();
SpaceBbQueryFunc :: #type proc();
SpaceShapeQueryFunc :: #type proc();
SpaceBodyIteratorFunc :: #type proc();
SpaceShapeIteratorFunc :: #type proc();
SpaceConstraintIteratorFunc :: #type proc();
SpaceDebugDrawCircleImpl :: #type proc();
SpaceDebugDrawSegmentImpl :: #type proc();
SpaceDebugDrawFatSegmentImpl :: #type proc();
SpaceDebugDrawPolygonImpl :: #type proc();
SpaceDebugDrawDotImpl :: #type proc();
SpaceDebugDrawColorForShapeImpl :: #type proc "stdcall" (shape: ^Shape, data: ^DataPointer) -> SpaceDebugColor;
ShapeCacheDataImpl :: #type proc();
ShapeDestroyImpl :: #type proc();
ShapePointQueryImpl :: #type proc();
ShapeSegmentQueryImpl :: #type proc();
ConstraintPreStepImpl :: #type proc();
ConstraintApplyCachedImpulseImpl :: #type proc();
ConstraintApplyImpulseImpl :: #type proc();
ConstraintGetImpulseImpl :: #type proc();
SpaceArbiterApplyImpulseFunc :: #type proc();

BodyType :: enum i32 {
    DYNAMIC,
    KINEMATIC,
    STATIC,
};

SpaceDebugDrawFlags :: enum i32 {
    SHAPES = 1,
    CONSTRAINTS = 2,
    COLLISION_POINTS = 4,
};

ArbiterState :: enum i32 {
    ARBITER_STATE_FIRST_COLLISION,
    ARBITER_STATE_NORMAL,
    ARBITER_STATE_IGNORE,
    ARBITER_STATE_CACHED,
    ARBITER_STATE_INVALIDATED,
};

ShapeType :: enum i32 {
    CIRCLE_SHAPE,
    SEGMENT_SHAPE,
    POLY_SHAPE,
    NUM_SHAPES,
};

Vect :: struct #packed {
    x : Float,
    y : Float,
};

Transform :: struct #packed {
    a : Float,
    b : Float,
    c : Float,
    d : Float,
    tx : Float,
    ty : Float,
};

Mat2X2 :: struct #packed {
    a : Float,
    b : Float,
    c : Float,
    d : Float,
};

Array :: struct #packed {
    num : _c.int,
    max : _c.int,
    arr : ^rawptr,
};

HashSet :: struct #packed {};

Body :: struct #packed {
    velocity_func : BodyVelocityFunc,
    position_func : BodyPositionFunc,
    m : Float,
    m_inv : Float,
    i : Float,
    i_inv : Float,
    cog : Vect,
    p : Vect,
    v : Vect,
    f : Vect,
    a : Float,
    w : Float,
    t : Float,
    transform : Transform,
    user_data : DataPointer,
    v_bias : Vect,
    w_bias : Float,
    space : ^Space,
    shape_list : ^Shape,
    arbiter_list : ^Arbiter,
    constraint_list : ^Constraint,
    sleeping : AnonymousStruct1,
};

Shape :: struct #packed {
    klass : ^ShapeClass,
    space : ^Space,
    body : ^Body,
    mass_info : ShapeMassInfo,
    bb : Bb,
    sensor : Bool,
    e : Float,
    u : Float,
    surface_v : Vect,
    user_data : DataPointer,
    type : CollisionType,
    filter : ShapeFilter,
    next : ^Shape,
    prev : ^Shape,
    hashid : HashValue,
};

CircleShape :: struct #packed {
    shape : Shape,
    c : Vect,
    tc : Vect,
    r : Float,
};

SegmentShape :: struct #packed {
    shape : Shape,
    a : Vect,
    b : Vect,
    n : Vect,
    ta : Vect,
    tb : Vect,
    tn : Vect,
    r : Float,
    a_tangent : Vect,
    b_tangent : Vect,
};

PolyShape :: struct #packed {
    shape : Shape,
    r : Float,
    count : _c.int,
    planes : ^SplittingPlane,
    private_planes : [12]SplittingPlane,
};

Constraint :: struct #packed {
    klass : ^ConstraintClass,
    space : ^Space,
    a : ^Body,
    b : ^^Body,
    next_a : ^Constraint,
    next_b : ^^Constraint,
    max_force : Float,
    error_bias : Float,
    max_bias : Float,
    collide_bodies : Bool,
    pre_solve : ConstraintPreSolveFunc,
    post_solve : ConstraintPostSolveFunc,
    user_data : DataPointer,
};

PinJoint :: struct #packed {
    constraint : Constraint,
    anchor_a : Vect,
    anchor_b : Vect,
    dist : Float,
    r1 : Vect,
    r2 : Vect,
    n : Vect,
    n_mass : Float,
    jn_acc : Float,
    bias : Float,
};

SlideJoint :: struct #packed {
    constraint : Constraint,
    anchor_a : Vect,
    anchor_b : Vect,
    min : Float,
    max : Float,
    r1 : Vect,
    r2 : Vect,
    n : Vect,
    n_mass : Float,
    jn_acc : Float,
    bias : Float,
};

PivotJoint :: struct #packed {
    constraint : Constraint,
    anchor_a : Vect,
    anchor_b : Vect,
    r1 : Vect,
    r2 : Vect,
    k : Mat2X2,
    j_acc : Vect,
    bias : Vect,
};

GrooveJoint :: struct #packed {
    constraint : Constraint,
    grv_n : Vect,
    grv_a : Vect,
    grv_b : Vect,
    anchor_b : Vect,
    grv_tn : Vect,
    clamp : Float,
    r1 : Vect,
    r2 : Vect,
    k : Mat2X2,
    j_acc : Vect,
    bias : Vect,
};

DampedSpring :: struct #packed {
    constraint : Constraint,
    anchor_a : Vect,
    anchor_b : Vect,
    rest_length : Float,
    stiffness : Float,
    damping : Float,
    spring_force_func : DampedSpringForceFunc,
    target_vrn : Float,
    v_coef : Float,
    r1 : Vect,
    r2 : Vect,
    n_mass : Float,
    n : Vect,
    j_acc : Float,
};

DampedRotarySpring :: struct #packed {
    constraint : Constraint,
    rest_angle : Float,
    stiffness : Float,
    damping : Float,
    spring_torque_func : DampedRotarySpringTorqueFunc,
    target_wrn : Float,
    w_coef : Float,
    i_sum : Float,
    j_acc : Float,
};

RotaryLimitJoint :: struct #packed {
    constraint : Constraint,
    min : Float,
    max : Float,
    i_sum : Float,
    bias : Float,
    j_acc : Float,
};

RatchetJoint :: struct #packed {
    constraint : Constraint,
    angle : Float,
    phase : Float,
    ratchet : Float,
    i_sum : Float,
    bias : Float,
    j_acc : Float,
};

GearJoint :: struct #packed {
    constraint : Constraint,
    phase : Float,
    ratio : Float,
    ratio_inv : Float,
    i_sum : Float,
    bias : Float,
    j_acc : Float,
};

SimpleMotorJoint :: struct #packed {};

CollisionHandler :: struct #packed {
    type_a : CollisionType,
    type_b : CollisionType,
    begin_func : CollisionBeginFunc,
    pre_solve_func : CollisionPreSolveFunc,
    post_solve_func : CollisionPostSolveFunc,
    separate_func : CollisionSeparateFunc,
    user_data : DataPointer,
};

ContactPointSet :: struct #packed {
    count : _c.int,
    normal : Vect,
    points : [2]AnonymousStruct0,
};

Arbiter :: struct #packed {
    e : Float,
    u : Float,
    surface_vr : Vect,
    data : DataPointer,
    a : ^Shape,
    b : ^^Shape,
    body_a : ^Body,
    body_b : ^^Body,
    thread_a : ArbiterThread,
    thread_b : ArbiterThread,
    count : _c.int,
    contacts : ^Contact,
    n : Vect,
    handler : ^CollisionHandler,
    handler_a : ^^CollisionHandler,
    handler_b : ^^CollisionHandler,
    swapped : Bool,
    stamp : Timestamp,
    state : ArbiterState,
};

Space :: struct #packed {
    iterations : _c.int,
    gravity : Vect,
    damping : Float,
    idle_speed_threshold : Float,
    sleep_time_threshold : Float,
    collision_slop : Float,
    collision_bias : Float,
    collision_persistence : Timestamp,
    user_data : DataPointer,
    stamp : Timestamp,
    curr_dt : Float,
    dynamic_bodies : ^Array,
    static_bodies : ^Array,
    roused_bodies : ^Array,
    sleeping_components : ^Array,
    shape_id_counter : HashValue,
    static_shapes : ^SpatialIndex,
    dynamic_shapes : ^SpatialIndex,
    constraints : ^Array,
    arbiters : ^Array,
    contact_buffers_head : ^ContactBufferHeader,
    cached_arbiters : ^HashSet,
    pooled_arbiters : ^Array,
    allocated_buffers : ^Array,
    locked : _c.uint,
    uses_wildcards : Bool,
    collision_handlers : ^HashSet,
    default_handler : CollisionHandler,
    skip_post_step : Bool,
    post_step_callbacks : ^Array,
    static_body : ^Body,
    staticbody : Body,
};

Bb :: struct #packed {
    l : Float,
    b : Float,
    r : Float,
    t : Float,
};

SpatialIndexClass :: struct #packed {
    destroy : SpatialIndexDestroyImpl,
    count : SpatialIndexCountImpl,
    each : SpatialIndexEachImpl,
    contains : SpatialIndexContainsImpl,
    insert : SpatialIndexInsertImpl,
    remove : SpatialIndexRemoveImpl,
    reindex : SpatialIndexReindexImpl,
    reindex_object : SpatialIndexReindexObjectImpl,
    reindex_query : SpatialIndexReindexQueryImpl,
    query : SpatialIndexQueryImpl,
    segment_query : SpatialIndexSegmentQueryImpl,
};

SpatialIndex :: struct #packed {
    klass : ^SpatialIndexClass,
    bbfunc : SpatialIndexBbFunc,
    static_index : ^SpatialIndex,
    dynamic_index : ^^SpatialIndex,
};

SpaceHash :: struct #packed {};

BbTree :: struct #packed {};

Sweep1D :: struct #packed {};

AnonymousStruct0 :: struct #packed {
    point_a : Vect,
    point_b : Vect,
    distance : Float,
};

PointQueryInfo :: struct #packed {
    shape : ^Shape,
    point : Vect,
    distance : Float,
    gradient : Vect,
};

SegmentQueryInfo :: struct #packed {
    shape : ^Shape,
    point : Vect,
    normal : Vect,
    alpha : Float,
};

ShapeFilter :: struct #packed {
    group : Group,
    categories : Bitmask,
    mask : Bitmask,
};

SimpleMotor :: struct #packed {
    constraint : Constraint,
    rate : Float,
    i_sum : Float,
    j_acc : Float,
};

SpaceDebugColor :: struct #packed {
    r : _c.float,
    g : _c.float,
    b : _c.float,
    a : _c.float,
};

SpaceDebugDrawOptions :: struct #packed {
    draw_circle : SpaceDebugDrawCircleImpl,
    draw_segment : SpaceDebugDrawSegmentImpl,
    draw_fat_segment : SpaceDebugDrawFatSegmentImpl,
    draw_polygon : SpaceDebugDrawPolygonImpl,
    draw_dot : SpaceDebugDrawDotImpl,
    flags : SpaceDebugDrawFlags,
    shape_outline_color : SpaceDebugColor,
    pad: u32,
    color_for_shape : SpaceDebugDrawColorForShapeImpl,
    constraint_color : SpaceDebugColor,
    collision_point_color : SpaceDebugColor,
    data : DataPointer,
};

AnonymousStruct1 :: struct #packed {
    root : ^Body,
    next : ^Body,
    idle_time : Float,
};

ArbiterThread :: struct #packed {};

Contact :: struct #packed {};

CollisionInfo :: struct #packed {
    a : ^Shape,
    b : ^^Shape,
    id : CollisionId,
    n : Vect,
    count : _c.int,
    arr : ^Contact,
};

ShapeMassInfo :: struct #packed {};

ShapeClass :: struct #packed {
    type : ShapeType,
    cache_data : ShapeCacheDataImpl,
    destroy : ShapeDestroyImpl,
    point_query : ShapePointQueryImpl,
    segment_query : ShapeSegmentQueryImpl,
};

SplittingPlane :: struct #packed {};

ConstraintClass :: struct #packed {
    pre_step : ConstraintPreStepImpl,
    apply_cached_impulse : ConstraintApplyCachedImpulseImpl,
    apply_impulse : ConstraintApplyImpulseImpl,
    get_impulse : ConstraintGetImpulseImpl,
};

ContactBufferHeader :: struct #packed {};

PostStepCallback :: struct #packed {
    func : PostStepFunc,
    key : rawptr,
    data : rawptr,
};

chipmunk_Funcs :: struct {
    message : proc "c" (
        condition : cstring,
        file : cstring,
        line : _c.int,
        is_error : _c.int,
        is_hard_error : _c.int,
        message : cstring
    ),
    fmax : proc "c" (
        a : Float,
        b : Float
    ) -> Float,
    fmin : proc "c" (
        a : Float,
        b : Float
    ) -> Float,
    fabs : proc "c" (f : Float) -> Float,
    fclamp : proc "c" (
        f : Float,
        min : Float,
        max : Float
    ) -> Float,
    fclamp01 : proc "c" (f : Float) -> Float,
    flerp : proc "c" (
        f1 : Float,
        f2 : Float,
        t : Float
    ) -> Float,
    flerpconst : proc "c" (
        f1 : Float,
        f2 : Float,
        d : Float
    ) -> Float,
    v : proc "c" (
        x : Float,
        y : Float
    ) -> Vect,
    veql : proc "c" (
        v1 : Vect,
        v2 : Vect
    ) -> Bool,
    vadd : proc "c" (
        v1 : Vect,
        v2 : Vect
    ) -> Vect,
    vsub : proc "c" (
        v1 : Vect,
        v2 : Vect
    ) -> Vect,
    vneg : proc "c" (v : Vect) -> Vect,
    vmult : proc "c" (
        v : Vect,
        s : Float
    ) -> Vect,
    vdot : proc "c" (
        v1 : Vect,
        v2 : Vect
    ) -> Float,
    vcross : proc "c" (
        v1 : Vect,
        v2 : Vect
    ) -> Float,
    vperp : proc "c" (v : Vect) -> Vect,
    vrperp : proc "c" (v : Vect) -> Vect,
    vproject : proc "c" (
        v1 : Vect,
        v2 : Vect
    ) -> Vect,
    vforangle : proc "c" (a : Float) -> Vect,
    vtoangle : proc "c" (v : Vect) -> Float,
    vrotate : proc "c" (
        v1 : Vect,
        v2 : Vect
    ) -> Vect,
    vunrotate : proc "c" (
        v1 : Vect,
        v2 : Vect
    ) -> Vect,
    vlengthsq : proc "c" (v : Vect) -> Float,
    vlength : proc "c" (v : Vect) -> Float,
    vlerp : proc "c" (
        v1 : Vect,
        v2 : Vect,
        t : Float
    ) -> Vect,
    vnormalize : proc "c" (v : Vect) -> Vect,
    vslerp : proc "c" (
        v1 : Vect,
        v2 : Vect,
        t : Float
    ) -> Vect,
    vslerpconst : proc "c" (
        v1 : Vect,
        v2 : Vect,
        a : Float
    ) -> Vect,
    vclamp : proc "c" (
        v : Vect,
        len : Float
    ) -> Vect,
    vlerpconst : proc "c" (
        v1 : Vect,
        v2 : Vect,
        d : Float
    ) -> Vect,
    vdist : proc "c" (
        v1 : Vect,
        v2 : Vect
    ) -> Float,
    vdistsq : proc "c" (
        v1 : Vect,
        v2 : Vect
    ) -> Float,
    vnear : proc "c" (
        v1 : Vect,
        v2 : Vect,
        dist : Float
    ) -> Bool,
    mat_2x_2_new : proc "c" (
        a : Float,
        b : Float,
        c : Float,
        d : Float
    ) -> Mat2X2,
    mat_2x_2_transform : proc "c" (
        m : Mat2X2,
        v : Vect
    ) -> Vect,
    bb_new : proc "c" (
        l : Float,
        b : Float,
        r : Float,
        t : Float
    ) -> Bb,
    bb_new_for_extents : proc "c" (
        c : Vect,
        hw : Float,
        hh : Float
    ) -> Bb,
    bb_new_for_circle : proc "c" (
        p : Vect,
        r : Float
    ) -> Bb,
    bb_intersects : proc "c" (
        a : Bb,
        b : Bb
    ) -> Bool,
    bb_contains_bb : proc "c" (
        bb : Bb,
        other : Bb
    ) -> Bool,
    bb_contains_vect : proc "c" (
        bb : Bb,
        v : Vect
    ) -> Bool,
    bb_merge : proc "c" (
        a : Bb,
        b : Bb
    ) -> Bb,
    bb_expand : proc "c" (
        bb : Bb,
        v : Vect
    ) -> Bb,
    bb_center : proc "c" (bb : Bb) -> Vect,
    bb_area : proc "c" (bb : Bb) -> Float,
    bb_merged_area : proc "c" (
        a : Bb,
        b : Bb
    ) -> Float,
    bb_segment_query : proc "c" (
        bb : Bb,
        a : Vect,
        b : Vect
    ) -> Float,
    bb_intersects_segment : proc "c" (
        bb : Bb,
        a : Vect,
        b : Vect
    ) -> Bool,
    bb_clamp_vect : proc "c" (
        bb : Bb,
        v : Vect
    ) -> Vect,
    bb_wrap_vect : proc "c" (
        bb : Bb,
        v : Vect
    ) -> Vect,
    bb_offset : proc "c" (
        bb : Bb,
        v : Vect
    ) -> Bb,
    transform_new : proc "c" (
        a : Float,
        b : Float,
        c : Float,
        d : Float,
        tx : Float,
        ty : Float
    ) -> Transform,
    transform_new_transpose : proc "c" (
        a : Float,
        c : Float,
        tx : Float,
        b : Float,
        d : Float,
        ty : Float
    ) -> Transform,
    transform_inverse : proc "c" (t : Transform) -> Transform,
    transform_mult : proc "c" (
        t1 : Transform,
        t2 : Transform
    ) -> Transform,
    transform_point : proc "c" (
        t : Transform,
        p : Vect
    ) -> Vect,
    transform_vect : proc "c" (
        t : Transform,
        v : Vect
    ) -> Vect,
    transformb_bb : proc "c" (
        t : Transform,
        bb : Bb
    ) -> Bb,
    transform_translate : proc "c" (translate : Vect) -> Transform,
    transform_scale : proc "c" (
        scale_x : Float,
        scale_y : Float
    ) -> Transform,
    transform_rotate : proc "c" (radians : Float) -> Transform,
    transform_rigid : proc "c" (
        translate : Vect,
        radians : Float
    ) -> Transform,
    transform_rigid_inverse : proc "c" (t : Transform) -> Transform,
    transform_wrap : proc "c" (
        outer : Transform,
        inner : Transform
    ) -> Transform,
    transform_wrap_inverse : proc "c" (
        outer : Transform,
        inner : Transform
    ) -> Transform,
    transform_ortho : proc "c" (bb : Bb) -> Transform,
    transform_bone_scale : proc "c" (
        v0 : Vect,
        v1 : Vect
    ) -> Transform,
    transform_axial_scale : proc "c" (
        axis : Vect,
        pivot : Vect,
        scale : Float
    ) -> Transform,
    space_hash_alloc : proc "c" () -> ^SpaceHash,
    space_hash_init : proc "c" (
        hash : ^SpaceHash,
        celldim : Float,
        numcells : _c.int,
        bbfunc : SpatialIndexBbFunc,
        static_index : ^SpatialIndex
    ) -> ^SpatialIndex,
    space_hash_new : proc "c" (
        celldim : Float,
        cells : _c.int,
        bbfunc : SpatialIndexBbFunc,
        static_index : ^SpatialIndex
    ) -> ^SpatialIndex,
    space_hash_resize : proc "c" (
        hash : ^SpaceHash,
        celldim : Float,
        numcells : _c.int
    ),
    bb_tree_alloc : proc "c" () -> ^BbTree,
    bb_tree_init : proc "c" (
        tree : ^BbTree,
        bbfunc : SpatialIndexBbFunc,
        static_index : ^SpatialIndex
    ) -> ^SpatialIndex,
    bb_tree_new : proc "c" (
        bbfunc : SpatialIndexBbFunc,
        static_index : ^SpatialIndex
    ) -> ^SpatialIndex,
    bb_tree_optimize : proc "c" (index : ^SpatialIndex),
    bb_tree_set_velocity_func : proc "c" (
        index : ^SpatialIndex,
        func : BbTreeVelocityFunc
    ),
    sweep_1d_alloc : proc "c" () -> ^Sweep1D,
    sweep_1d_init : proc "c" (
        sweep : ^Sweep1D,
        bbfunc : SpatialIndexBbFunc,
        static_index : ^SpatialIndex
    ) -> ^SpatialIndex,
    sweep_1d_new : proc "c" (
        bbfunc : SpatialIndexBbFunc,
        static_index : ^SpatialIndex
    ) -> ^SpatialIndex,
    spatial_index_free : proc "c" (index : ^SpatialIndex),
    spatial_index_collide_static : proc "c" (
        dynamic_index : ^SpatialIndex,
        static_index : ^SpatialIndex,
        func : SpatialIndexQueryFunc,
        data : rawptr
    ),
    spatial_index_destroy : proc "c" (index : ^SpatialIndex),
    spatial_index_count : proc "c" (index : ^SpatialIndex) -> _c.int,
    spatial_index_each : proc "c" (
        index : ^SpatialIndex,
        func : SpatialIndexIteratorFunc,
        data : rawptr
    ),
    spatial_index_contains : proc "c" (
        index : ^SpatialIndex,
        obj : rawptr,
        hashid : HashValue
    ) -> Bool,
    spatial_index_insert : proc "c" (
        index : ^SpatialIndex,
        obj : rawptr,
        hashid : HashValue
    ),
    spatial_index_remove : proc "c" (
        index : ^SpatialIndex,
        obj : rawptr,
        hashid : HashValue
    ),
    spatial_index_reindex : proc "c" (index : ^SpatialIndex),
    spatial_index_reindex_object : proc "c" (
        index : ^SpatialIndex,
        obj : rawptr,
        hashid : HashValue
    ),
    spatial_index_query : proc "c" (
        index : ^SpatialIndex,
        obj : rawptr,
        bb : Bb,
        func : SpatialIndexQueryFunc,
        data : rawptr
    ),
    spatial_index_segment_query : proc "c" (
        index : ^SpatialIndex,
        obj : rawptr,
        a : Vect,
        b : Vect,
        t_exit : Float,
        func : SpatialIndexSegmentQueryFunc,
        data : rawptr
    ),
    spatial_index_reindex_query : proc "c" (
        index : ^SpatialIndex,
        func : SpatialIndexQueryFunc,
        data : rawptr
    ),
    arbiter_get_restitution : proc "c" (arb : ^Arbiter) -> Float,
    arbiter_set_restitution : proc "c" (
        arb : ^Arbiter,
        restitution : Float
    ),
    arbiter_get_friction : proc "c" (arb : ^Arbiter) -> Float,
    arbiter_set_friction : proc "c" (
        arb : ^Arbiter,
        friction : Float
    ),
    arbiter_get_surface_velocity : proc "c" (arb : ^Arbiter) -> Vect,
    arbiter_set_surface_velocity : proc "c" (
        arb : ^Arbiter,
        vr : Vect
    ),
    arbiter_get_user_data : proc "c" (arb : ^Arbiter) -> DataPointer,
    arbiter_set_user_data : proc "c" (
        arb : ^Arbiter,
        user_data : DataPointer
    ),
    arbiter_total_impulse : proc "c" (arb : ^Arbiter) -> Vect,
    arbiter_total_ke : proc "c" (arb : ^Arbiter) -> Float,
    arbiter_ignore : proc "c" (arb : ^Arbiter) -> Bool,
    arbiter_get_shapes : proc "c" (
        arb : ^Arbiter,
        a : ^^Shape,
        b : ^^Shape
    ),
    arbiter_get_bodies : proc "c" (
        arb : ^Arbiter,
        a : ^^Body,
        b : ^^Body
    ),
    arbiter_get_contact_point_set : proc "c" (arb : ^Arbiter) -> ContactPointSet,
    arbiter_set_contact_point_set : proc "c" (
        arb : ^Arbiter,
        set : ^ContactPointSet
    ),
    arbiter_is_first_contact : proc "c" (arb : ^Arbiter) -> Bool,
    arbiter_is_removal : proc "c" (arb : ^Arbiter) -> Bool,
    arbiter_get_count : proc "c" (arb : ^Arbiter) -> _c.int,
    arbiter_get_normal : proc "c" (arb : ^Arbiter) -> Vect,
    arbiter_get_point_a : proc "c" (
        arb : ^Arbiter,
        i : _c.int
    ) -> Vect,
    arbiter_get_point_b : proc "c" (
        arb : ^Arbiter,
        i : _c.int
    ) -> Vect,
    arbiter_get_depth : proc "c" (
        arb : ^Arbiter,
        i : _c.int
    ) -> Float,
    arbiter_call_wildcard_begin_a : proc "c" (
        arb : ^Arbiter,
        space : ^Space
    ) -> Bool,
    arbiter_call_wildcard_begin_b : proc "c" (
        arb : ^Arbiter,
        space : ^Space
    ) -> Bool,
    arbiter_call_wildcard_pre_solve_a : proc "c" (
        arb : ^Arbiter,
        space : ^Space
    ) -> Bool,
    arbiter_call_wildcard_pre_solve_b : proc "c" (
        arb : ^Arbiter,
        space : ^Space
    ) -> Bool,
    arbiter_call_wildcard_post_solve_a : proc "c" (
        arb : ^Arbiter,
        space : ^Space
    ),
    arbiter_call_wildcard_post_solve_b : proc "c" (
        arb : ^Arbiter,
        space : ^Space
    ),
    arbiter_call_wildcard_separate_a : proc "c" (
        arb : ^Arbiter,
        space : ^Space
    ),
    arbiter_call_wildcard_separate_b : proc "c" (
        arb : ^Arbiter,
        space : ^Space
    ),
    body_alloc : proc "c" () -> ^Body,
    body_init : proc "c" (
        body : ^Body,
        mass : Float,
        moment : Float
    ) -> ^Body,
    body_new : proc "c" (
        mass : Float,
        moment : Float
    ) -> ^Body,
    body_new_kinematic : proc "c" () -> ^Body,
    body_new_static : proc "c" () -> ^Body,
    body_destroy : proc "c" (body : ^Body),
    body_free : proc "c" (body : ^Body),
    body_activate : proc "c" (body : ^Body),
    body_activate_static : proc "c" (
        body : ^Body,
        filter : ^Shape
    ),
    body_sleep : proc "c" (body : ^Body),
    body_sleep_with_group : proc "c" (
        body : ^Body,
        group : ^Body
    ),
    body_is_sleeping : proc "c" (body : ^Body) -> Bool,
    body_get_type : proc "c" (body : ^Body) -> BodyType,
    body_set_type : proc "c" (
        body : ^Body,
        type : BodyType
    ),
    body_get_space : proc "c" (body : ^Body) -> ^Space,
    body_get_mass : proc "c" (body : ^Body) -> Float,
    body_set_mass : proc "c" (
        body : ^Body,
        m : Float
    ),
    body_get_moment : proc "c" (body : ^Body) -> Float,
    body_set_moment : proc "c" (
        body : ^Body,
        i : Float
    ),
    body_get_position : proc "c" (body : ^Body) -> Vect,
    body_set_position : proc "c" (
        body : ^Body,
        pos : Vect
    ),
    body_get_center_of_gravity : proc "c" (body : ^Body) -> Vect,
    body_set_center_of_gravity : proc "c" (
        body : ^Body,
        cog : Vect
    ),
    body_get_velocity : proc "c" (body : ^Body) -> Vect,
    body_set_velocity : proc "c" (
        body : ^Body,
        velocity : Vect
    ),
    body_get_force : proc "c" (body : ^Body) -> Vect,
    body_set_force : proc "c" (
        body : ^Body,
        force : Vect
    ),
    body_get_angle : proc "c" (body : ^Body) -> Float,
    body_set_angle : proc "c" (
        body : ^Body,
        a : Float
    ),
    body_get_angular_velocity : proc "c" (body : ^Body) -> Float,
    body_set_angular_velocity : proc "c" (
        body : ^Body,
        angular_velocity : Float
    ),
    body_get_torque : proc "c" (body : ^Body) -> Float,
    body_set_torque : proc "c" (
        body : ^Body,
        torque : Float
    ),
    body_get_rotation : proc "c" (body : ^Body) -> Vect,
    body_get_user_data : proc "c" (body : ^Body) -> DataPointer,
    body_set_user_data : proc "c" (
        body : ^Body,
        user_data : DataPointer
    ),
    body_set_velocity_update_func : proc "c" (
        body : ^Body,
        velocity_func : BodyVelocityFunc
    ),
    body_set_position_update_func : proc "c" (
        body : ^Body,
        position_func : BodyPositionFunc
    ),
    body_update_velocity : proc "c" (
        body : ^Body,
        gravity : Vect,
        damping : Float,
        dt : Float
    ),
    body_update_position : proc "c" (
        body : ^Body,
        dt : Float
    ),
    body_local_to_world : proc "c" (
        body : ^Body,
        point : Vect
    ) -> Vect,
    body_world_to_local : proc "c" (
        body : ^Body,
        point : Vect
    ) -> Vect,
    body_apply_force_at_world_point : proc "c" (
        body : ^Body,
        force : Vect,
        point : Vect
    ),
    body_apply_force_at_local_point : proc "c" (
        body : ^Body,
        force : Vect,
        point : Vect
    ),
    body_apply_impulse_at_world_point : proc "c" (
        body : ^Body,
        impulse : Vect,
        point : Vect
    ),
    body_apply_impulse_at_local_point : proc "c" (
        body : ^Body,
        impulse : Vect,
        point : Vect
    ),
    body_get_velocity_at_world_point : proc "c" (
        body : ^Body,
        point : Vect
    ) -> Vect,
    body_get_velocity_at_local_point : proc "c" (
        body : ^Body,
        point : Vect
    ) -> Vect,
    body_kinetic_energy : proc "c" (body : ^Body) -> Float,
    body_each_shape : proc "c" (
        body : ^Body,
        func : BodyShapeIteratorFunc,
        data : rawptr
    ),
    body_each_constraint : proc "c" (
        body : ^Body,
        func : BodyConstraintIteratorFunc,
        data : rawptr
    ),
    body_each_arbiter : proc "c" (
        body : ^Body,
        func : BodyArbiterIteratorFunc,
        data : rawptr
    ),
    shape_filter_new : proc "c" (
        group : Group,
        categories : Bitmask,
        mask : Bitmask
    ) -> ShapeFilter,
    shape_destroy : proc "c" (shape : ^Shape),
    shape_free : proc "c" (shape : ^Shape),
    shape_cache_bb : proc "c" (shape : ^Shape) -> Bb,
    shape_update : proc "c" (
        shape : ^Shape,
        transform : Transform
    ) -> Bb,
    shape_point_query : proc "c" (
        shape : ^Shape,
        p : Vect,
        out : ^PointQueryInfo
    ) -> Float,
    shape_segment_query : proc "c" (
        shape : ^Shape,
        a : Vect,
        b : Vect,
        radius : Float,
        info : ^SegmentQueryInfo
    ) -> Bool,
    shapes_collide : proc "c" (
        a : ^Shape,
        b : ^Shape
    ) -> ContactPointSet,
    shape_get_space : proc "c" (shape : ^Shape) -> ^Space,
    shape_get_body : proc "c" (shape : ^Shape) -> ^Body,
    shape_set_body : proc "c" (
        shape : ^Shape,
        body : ^Body
    ),
    shape_get_mass : proc "c" (shape : ^Shape) -> Float,
    shape_set_mass : proc "c" (
        shape : ^Shape,
        mass : Float
    ),
    shape_get_density : proc "c" (shape : ^Shape) -> Float,
    shape_set_density : proc "c" (
        shape : ^Shape,
        density : Float
    ),
    shape_get_moment : proc "c" (shape : ^Shape) -> Float,
    shape_get_area : proc "c" (shape : ^Shape) -> Float,
    shape_get_center_of_gravity : proc "c" (shape : ^Shape) -> Vect,
    shape_get_bb : proc "c" (shape : ^Shape) -> Bb,
    shape_get_sensor : proc "c" (shape : ^Shape) -> Bool,
    shape_set_sensor : proc "c" (
        shape : ^Shape,
        sensor : Bool
    ),
    shape_get_elasticity : proc "c" (shape : ^Shape) -> Float,
    shape_set_elasticity : proc "c" (
        shape : ^Shape,
        elasticity : Float
    ),
    shape_get_friction : proc "c" (shape : ^Shape) -> Float,
    shape_set_friction : proc "c" (
        shape : ^Shape,
        friction : Float
    ),
    shape_get_surface_velocity : proc "c" (shape : ^Shape) -> Vect,
    shape_set_surface_velocity : proc "c" (
        shape : ^Shape,
        surface_velocity : Vect
    ),
    shape_get_user_data : proc "c" (shape : ^Shape) -> DataPointer,
    shape_set_user_data : proc "c" (
        shape : ^Shape,
        user_data : DataPointer
    ),
    shape_get_collision_type : proc "c" (shape : ^Shape) -> CollisionType,
    shape_set_collision_type : proc "c" (
        shape : ^Shape,
        collision_type : CollisionType
    ),
    shape_get_filter : proc "c" (shape : ^Shape) -> ShapeFilter,
    shape_set_filter : proc "c" (
        shape : ^Shape,
        filter : ShapeFilter
    ),
    circle_shape_alloc : proc "c" () -> ^CircleShape,
    circle_shape_init : proc "c" (
        circle : ^CircleShape,
        body : ^Body,
        radius : Float,
        offset : Vect
    ) -> ^CircleShape,
    circle_shape_new : proc "c" (
        body : ^Body,
        radius : Float,
        offset : Vect
    ) -> ^Shape,
    circle_shape_get_offset : proc "c" (shape : ^Shape) -> Vect,
    circle_shape_get_radius : proc "c" (shape : ^Shape) -> Float,
    segment_shape_alloc : proc "c" () -> ^SegmentShape,
    segment_shape_init : proc "c" (
        seg : ^SegmentShape,
        body : ^Body,
        a : Vect,
        b : Vect,
        radius : Float
    ) -> ^SegmentShape,
    segment_shape_new : proc "c" (
        body : ^Body,
        a : Vect,
        b : Vect,
        radius : Float
    ) -> ^Shape,
    segment_shape_set_neighbors : proc "c" (
        shape : ^Shape,
        prev : Vect,
        next : Vect
    ),
    segment_shape_get_a : proc "c" (shape : ^Shape) -> Vect,
    segment_shape_get_b : proc "c" (shape : ^Shape) -> Vect,
    segment_shape_get_normal : proc "c" (shape : ^Shape) -> Vect,
    segment_shape_get_radius : proc "c" (shape : ^Shape) -> Float,
    poly_shape_alloc : proc "c" () -> ^PolyShape,
    poly_shape_init : proc "c" (
        poly : ^PolyShape,
        body : ^Body,
        count : _c.int,
        verts : ^Vect,
        transform : Transform,
        radius : Float
    ) -> ^PolyShape,
    poly_shape_init_raw : proc "c" (
        poly : ^PolyShape,
        body : ^Body,
        count : _c.int,
        verts : ^Vect,
        radius : Float
    ) -> ^PolyShape,
    poly_shape_new : proc "c" (
        body : ^Body,
        count : _c.int,
        verts : ^Vect,
        transform : Transform,
        radius : Float
    ) -> ^Shape,
    poly_shape_new_raw : proc "c" (
        body : ^Body,
        count : _c.int,
        verts : ^Vect,
        radius : Float
    ) -> ^Shape,
    box_shape_init : proc "c" (
        poly : ^PolyShape,
        body : ^Body,
        width : Float,
        height : Float,
        radius : Float
    ) -> ^PolyShape,
    box_shape_init_2 : proc "c" (
        poly : ^PolyShape,
        body : ^Body,
        box : Bb,
        radius : Float
    ) -> ^PolyShape,
    box_shape_new : proc "c" (
        body : ^Body,
        width : Float,
        height : Float,
        radius : Float
    ) -> ^Shape,
    box_shape_new_2 : proc "c" (
        body : ^Body,
        box : Bb,
        radius : Float
    ) -> ^Shape,
    poly_shape_get_count : proc "c" (shape : ^Shape) -> _c.int,
    poly_shape_get_vert : proc "c" (
        shape : ^Shape,
        index : _c.int
    ) -> Vect,
    poly_shape_get_radius : proc "c" (shape : ^Shape) -> Float,
    constraint_destroy : proc "c" (constraint : ^Constraint),
    constraint_free : proc "c" (constraint : ^Constraint),
    constraint_get_space : proc "c" (constraint : ^Constraint) -> ^Space,
    constraint_get_body_a : proc "c" (constraint : ^Constraint) -> ^Body,
    constraint_get_body_b : proc "c" (constraint : ^Constraint) -> ^Body,
    constraint_get_max_force : proc "c" (constraint : ^Constraint) -> Float,
    constraint_set_max_force : proc "c" (
        constraint : ^Constraint,
        max_force : Float
    ),
    constraint_get_error_bias : proc "c" (constraint : ^Constraint) -> Float,
    constraint_set_error_bias : proc "c" (
        constraint : ^Constraint,
        error_bias : Float
    ),
    constraint_get_max_bias : proc "c" (constraint : ^Constraint) -> Float,
    constraint_set_max_bias : proc "c" (
        constraint : ^Constraint,
        max_bias : Float
    ),
    constraint_get_collide_bodies : proc "c" (constraint : ^Constraint) -> Bool,
    constraint_set_collide_bodies : proc "c" (
        constraint : ^Constraint,
        collide_bodies : Bool
    ),
    constraint_get_pre_solve_func : proc "c" (constraint : ^Constraint) -> ConstraintPreSolveFunc,
    constraint_set_pre_solve_func : proc "c" (
        constraint : ^Constraint,
        pre_solve_func : ConstraintPreSolveFunc
    ),
    constraint_get_post_solve_func : proc "c" (constraint : ^Constraint) -> ConstraintPostSolveFunc,
    constraint_set_post_solve_func : proc "c" (
        constraint : ^Constraint,
        post_solve_func : ConstraintPostSolveFunc
    ),
    constraint_get_user_data : proc "c" (constraint : ^Constraint) -> DataPointer,
    constraint_set_user_data : proc "c" (
        constraint : ^Constraint,
        user_data : DataPointer
    ),
    constraint_get_impulse : proc "c" (constraint : ^Constraint) -> Float,
    constraint_is_pin_joint : proc "c" (constraint : ^Constraint) -> Bool,
    pin_joint_alloc : proc "c" () -> ^PinJoint,
    pin_joint_init : proc "c" (
        joint : ^PinJoint,
        a : ^Body,
        b : ^Body,
        anchor_a : Vect,
        anchor_b : Vect
    ) -> ^PinJoint,
    pin_joint_new : proc "c" (
        a : ^Body,
        b : ^Body,
        anchor_a : Vect,
        anchor_b : Vect
    ) -> ^Constraint,
    pin_joint_get_anchor_a : proc "c" (constraint : ^Constraint) -> Vect,
    pin_joint_set_anchor_a : proc "c" (
        constraint : ^Constraint,
        anchor_a : Vect
    ),
    pin_joint_get_anchor_b : proc "c" (constraint : ^Constraint) -> Vect,
    pin_joint_set_anchor_b : proc "c" (
        constraint : ^Constraint,
        anchor_b : Vect
    ),
    pin_joint_get_dist : proc "c" (constraint : ^Constraint) -> Float,
    pin_joint_set_dist : proc "c" (
        constraint : ^Constraint,
        dist : Float
    ),
    constraint_is_slide_joint : proc "c" (constraint : ^Constraint) -> Bool,
    slide_joint_alloc : proc "c" () -> ^SlideJoint,
    slide_joint_init : proc "c" (
        joint : ^SlideJoint,
        a : ^Body,
        b : ^Body,
        anchor_a : Vect,
        anchor_b : Vect,
        min : Float,
        max : Float
    ) -> ^SlideJoint,
    slide_joint_new : proc "c" (
        a : ^Body,
        b : ^Body,
        anchor_a : Vect,
        anchor_b : Vect,
        min : Float,
        max : Float
    ) -> ^Constraint,
    slide_joint_get_anchor_a : proc "c" (constraint : ^Constraint) -> Vect,
    slide_joint_set_anchor_a : proc "c" (
        constraint : ^Constraint,
        anchor_a : Vect
    ),
    slide_joint_get_anchor_b : proc "c" (constraint : ^Constraint) -> Vect,
    slide_joint_set_anchor_b : proc "c" (
        constraint : ^Constraint,
        anchor_b : Vect
    ),
    slide_joint_get_min : proc "c" (constraint : ^Constraint) -> Float,
    slide_joint_set_min : proc "c" (
        constraint : ^Constraint,
        min : Float
    ),
    slide_joint_get_max : proc "c" (constraint : ^Constraint) -> Float,
    slide_joint_set_max : proc "c" (
        constraint : ^Constraint,
        max : Float
    ),
    constraint_is_pivot_joint : proc "c" (constraint : ^Constraint) -> Bool,
    pivot_joint_alloc : proc "c" () -> ^PivotJoint,
    pivot_joint_init : proc "c" (
        joint : ^PivotJoint,
        a : ^Body,
        b : ^Body,
        anchor_a : Vect,
        anchor_b : Vect
    ) -> ^PivotJoint,
    pivot_joint_new : proc "c" (
        a : ^Body,
        b : ^Body,
        pivot : Vect
    ) -> ^Constraint,
    pivot_joint_new_2 : proc "c" (
        a : ^Body,
        b : ^Body,
        anchor_a : Vect,
        anchor_b : Vect
    ) -> ^Constraint,
    pivot_joint_get_anchor_a : proc "c" (constraint : ^Constraint) -> Vect,
    pivot_joint_set_anchor_a : proc "c" (
        constraint : ^Constraint,
        anchor_a : Vect
    ),
    pivot_joint_get_anchor_b : proc "c" (constraint : ^Constraint) -> Vect,
    pivot_joint_set_anchor_b : proc "c" (
        constraint : ^Constraint,
        anchor_b : Vect
    ),
    constraint_is_groove_joint : proc "c" (constraint : ^Constraint) -> Bool,
    groove_joint_alloc : proc "c" () -> ^GrooveJoint,
    groove_joint_init : proc "c" (
        joint : ^GrooveJoint,
        a : ^Body,
        b : ^Body,
        groove_a : Vect,
        groove_b : Vect,
        anchor_b : Vect
    ) -> ^GrooveJoint,
    groove_joint_new : proc "c" (
        a : ^Body,
        b : ^Body,
        groove_a : Vect,
        groove_b : Vect,
        anchor_b : Vect
    ) -> ^Constraint,
    groove_joint_get_groove_a : proc "c" (constraint : ^Constraint) -> Vect,
    groove_joint_set_groove_a : proc "c" (
        constraint : ^Constraint,
        groove_a : Vect
    ),
    groove_joint_get_groove_b : proc "c" (constraint : ^Constraint) -> Vect,
    groove_joint_set_groove_b : proc "c" (
        constraint : ^Constraint,
        groove_b : Vect
    ),
    groove_joint_get_anchor_b : proc "c" (constraint : ^Constraint) -> Vect,
    groove_joint_set_anchor_b : proc "c" (
        constraint : ^Constraint,
        anchor_b : Vect
    ),
    constraint_is_damped_spring : proc "c" (constraint : ^Constraint) -> Bool,
    damped_spring_alloc : proc "c" () -> ^DampedSpring,
    damped_spring_init : proc "c" (
        joint : ^DampedSpring,
        a : ^Body,
        b : ^Body,
        anchor_a : Vect,
        anchor_b : Vect,
        rest_length : Float,
        stiffness : Float,
        damping : Float
    ) -> ^DampedSpring,
    damped_spring_new : proc "c" (
        a : ^Body,
        b : ^Body,
        anchor_a : Vect,
        anchor_b : Vect,
        rest_length : Float,
        stiffness : Float,
        damping : Float
    ) -> ^Constraint,
    damped_spring_get_anchor_a : proc "c" (constraint : ^Constraint) -> Vect,
    damped_spring_set_anchor_a : proc "c" (
        constraint : ^Constraint,
        anchor_a : Vect
    ),
    damped_spring_get_anchor_b : proc "c" (constraint : ^Constraint) -> Vect,
    damped_spring_set_anchor_b : proc "c" (
        constraint : ^Constraint,
        anchor_b : Vect
    ),
    damped_spring_get_rest_length : proc "c" (constraint : ^Constraint) -> Float,
    damped_spring_set_rest_length : proc "c" (
        constraint : ^Constraint,
        rest_length : Float
    ),
    damped_spring_get_stiffness : proc "c" (constraint : ^Constraint) -> Float,
    damped_spring_set_stiffness : proc "c" (
        constraint : ^Constraint,
        stiffness : Float
    ),
    damped_spring_get_damping : proc "c" (constraint : ^Constraint) -> Float,
    damped_spring_set_damping : proc "c" (
        constraint : ^Constraint,
        damping : Float
    ),
    damped_spring_get_spring_force_func : proc "c" (constraint : ^Constraint) -> DampedSpringForceFunc,
    damped_spring_set_spring_force_func : proc "c" (
        constraint : ^Constraint,
        spring_force_func : DampedSpringForceFunc
    ),
    constraint_is_damped_rotary_spring : proc "c" (constraint : ^Constraint) -> Bool,
    damped_rotary_spring_alloc : proc "c" () -> ^DampedRotarySpring,
    damped_rotary_spring_init : proc "c" (
        joint : ^DampedRotarySpring,
        a : ^Body,
        b : ^Body,
        rest_angle : Float,
        stiffness : Float,
        damping : Float
    ) -> ^DampedRotarySpring,
    damped_rotary_spring_new : proc "c" (
        a : ^Body,
        b : ^Body,
        rest_angle : Float,
        stiffness : Float,
        damping : Float
    ) -> ^Constraint,
    damped_rotary_spring_get_rest_angle : proc "c" (constraint : ^Constraint) -> Float,
    damped_rotary_spring_set_rest_angle : proc "c" (
        constraint : ^Constraint,
        rest_angle : Float
    ),
    damped_rotary_spring_get_stiffness : proc "c" (constraint : ^Constraint) -> Float,
    damped_rotary_spring_set_stiffness : proc "c" (
        constraint : ^Constraint,
        stiffness : Float
    ),
    damped_rotary_spring_get_damping : proc "c" (constraint : ^Constraint) -> Float,
    damped_rotary_spring_set_damping : proc "c" (
        constraint : ^Constraint,
        damping : Float
    ),
    damped_rotary_spring_get_spring_torque_func : proc "c" (constraint : ^Constraint) -> DampedRotarySpringTorqueFunc,
    damped_rotary_spring_set_spring_torque_func : proc "c" (
        constraint : ^Constraint,
        spring_torque_func : DampedRotarySpringTorqueFunc
    ),
    constraint_is_rotary_limit_joint : proc "c" (constraint : ^Constraint) -> Bool,
    rotary_limit_joint_alloc : proc "c" () -> ^RotaryLimitJoint,
    rotary_limit_joint_init : proc "c" (
        joint : ^RotaryLimitJoint,
        a : ^Body,
        b : ^Body,
        min : Float,
        max : Float
    ) -> ^RotaryLimitJoint,
    rotary_limit_joint_new : proc "c" (
        a : ^Body,
        b : ^Body,
        min : Float,
        max : Float
    ) -> ^Constraint,
    rotary_limit_joint_get_min : proc "c" (constraint : ^Constraint) -> Float,
    rotary_limit_joint_set_min : proc "c" (
        constraint : ^Constraint,
        min : Float
    ),
    rotary_limit_joint_get_max : proc "c" (constraint : ^Constraint) -> Float,
    rotary_limit_joint_set_max : proc "c" (
        constraint : ^Constraint,
        max : Float
    ),
    constraint_is_ratchet_joint : proc "c" (constraint : ^Constraint) -> Bool,
    ratchet_joint_alloc : proc "c" () -> ^RatchetJoint,
    ratchet_joint_init : proc "c" (
        joint : ^RatchetJoint,
        a : ^Body,
        b : ^Body,
        phase : Float,
        ratchet : Float
    ) -> ^RatchetJoint,
    ratchet_joint_new : proc "c" (
        a : ^Body,
        b : ^Body,
        phase : Float,
        ratchet : Float
    ) -> ^Constraint,
    ratchet_joint_get_angle : proc "c" (constraint : ^Constraint) -> Float,
    ratchet_joint_set_angle : proc "c" (
        constraint : ^Constraint,
        angle : Float
    ),
    ratchet_joint_get_phase : proc "c" (constraint : ^Constraint) -> Float,
    ratchet_joint_set_phase : proc "c" (
        constraint : ^Constraint,
        phase : Float
    ),
    ratchet_joint_get_ratchet : proc "c" (constraint : ^Constraint) -> Float,
    ratchet_joint_set_ratchet : proc "c" (
        constraint : ^Constraint,
        ratchet : Float
    ),
    constraint_is_gear_joint : proc "c" (constraint : ^Constraint) -> Bool,
    gear_joint_alloc : proc "c" () -> ^GearJoint,
    gear_joint_init : proc "c" (
        joint : ^GearJoint,
        a : ^Body,
        b : ^Body,
        phase : Float,
        ratio : Float
    ) -> ^GearJoint,
    gear_joint_new : proc "c" (
        a : ^Body,
        b : ^Body,
        phase : Float,
        ratio : Float
    ) -> ^Constraint,
    gear_joint_get_phase : proc "c" (constraint : ^Constraint) -> Float,
    gear_joint_set_phase : proc "c" (
        constraint : ^Constraint,
        phase : Float
    ),
    gear_joint_get_ratio : proc "c" (constraint : ^Constraint) -> Float,
    gear_joint_set_ratio : proc "c" (
        constraint : ^Constraint,
        ratio : Float
    ),
    constraint_is_simple_motor : proc "c" (constraint : ^Constraint) -> Bool,
    simple_motor_alloc : proc "c" () -> ^SimpleMotor,
    simple_motor_init : proc "c" (
        joint : ^SimpleMotor,
        a : ^Body,
        b : ^Body,
        rate : Float
    ) -> ^SimpleMotor,
    simple_motor_new : proc "c" (
        a : ^Body,
        b : ^Body,
        rate : Float
    ) -> ^Constraint,
    simple_motor_get_rate : proc "c" (constraint : ^Constraint) -> Float,
    simple_motor_set_rate : proc "c" (
        constraint : ^Constraint,
        rate : Float
    ),
    space_alloc : proc "c" () -> ^Space,
    space_init : proc "c" (space : ^Space) -> ^Space,
    space_new : proc "c" () -> ^Space,
    space_destroy : proc "c" (space : ^Space),
    space_free : proc "c" (space : ^Space),
    space_get_iterations : proc "c" (space : ^Space) -> _c.int,
    space_set_iterations : proc "c" (
        space : ^Space,
        iterations : _c.int
    ),
    space_get_gravity : proc "c" (space : ^Space) -> Vect,
    space_set_gravity : proc "c" (
        space : ^Space,
        gravity : Vect
    ),
    space_get_damping : proc "c" (space : ^Space) -> Float,
    space_set_damping : proc "c" (
        space : ^Space,
        damping : Float
    ),
    space_get_idle_speed_threshold : proc "c" (space : ^Space) -> Float,
    space_set_idle_speed_threshold : proc "c" (
        space : ^Space,
        idle_speed_threshold : Float
    ),
    space_get_sleep_time_threshold : proc "c" (space : ^Space) -> Float,
    space_set_sleep_time_threshold : proc "c" (
        space : ^Space,
        sleep_time_threshold : Float
    ),
    space_get_collision_slop : proc "c" (space : ^Space) -> Float,
    space_set_collision_slop : proc "c" (
        space : ^Space,
        collision_slop : Float
    ),
    space_get_collision_bias : proc "c" (space : ^Space) -> Float,
    space_set_collision_bias : proc "c" (
        space : ^Space,
        collision_bias : Float
    ),
    space_get_collision_persistence : proc "c" (space : ^Space) -> Timestamp,
    space_set_collision_persistence : proc "c" (
        space : ^Space,
        collision_persistence : Timestamp
    ),
    space_get_user_data : proc "c" (space : ^Space) -> DataPointer,
    space_set_user_data : proc "c" (
        space : ^Space,
        user_data : DataPointer
    ),
    space_get_static_body : proc "c" (space : ^Space) -> ^Body,
    space_get_current_time_step : proc "c" (space : ^Space) -> Float,
    space_is_locked : proc "c" (space : ^Space) -> Bool,
    space_add_default_collision_handler : proc "c" (space : ^Space) -> ^CollisionHandler,
    space_add_collision_handler : proc "c" (
        space : ^Space,
        a : CollisionType,
        b : CollisionType
    ) -> ^CollisionHandler,
    space_add_wildcard_handler : proc "c" (
        space : ^Space,
        type : CollisionType
    ) -> ^CollisionHandler,
    space_add_shape : proc "c" (
        space : ^Space,
        shape : ^Shape
    ) -> ^Shape,
    space_add_body : proc "c" (
        space : ^Space,
        body : ^Body
    ) -> ^Body,
    space_add_constraint : proc "c" (
        space : ^Space,
        constraint : ^Constraint
    ) -> ^Constraint,
    space_remove_shape : proc "c" (
        space : ^Space,
        shape : ^Shape
    ),
    space_remove_body : proc "c" (
        space : ^Space,
        body : ^Body
    ),
    space_remove_constraint : proc "c" (
        space : ^Space,
        constraint : ^Constraint
    ),
    space_contains_shape : proc "c" (
        space : ^Space,
        shape : ^Shape
    ) -> Bool,
    space_contains_body : proc "c" (
        space : ^Space,
        body : ^Body
    ) -> Bool,
    space_contains_constraint : proc "c" (
        space : ^Space,
        constraint : ^Constraint
    ) -> Bool,
    space_add_post_step_callback : proc "c" (
        space : ^Space,
        func : PostStepFunc,
        key : rawptr,
        data : rawptr
    ) -> Bool,
    space_point_query : proc "c" (
        space : ^Space,
        point : Vect,
        max_distance : Float,
        filter : ShapeFilter,
        func : SpacePointQueryFunc,
        data : rawptr
    ),
    space_point_query_nearest : proc "c" (
        space : ^Space,
        point : Vect,
        max_distance : Float,
        filter : ShapeFilter,
        out : ^PointQueryInfo
    ) -> ^Shape,
    space_segment_query : proc "c" (
        space : ^Space,
        start : Vect,
        end : Vect,
        radius : Float,
        filter : ShapeFilter,
        func : SpaceSegmentQueryFunc,
        data : rawptr
    ),
    space_segment_query_first : proc "c" (
        space : ^Space,
        start : Vect,
        end : Vect,
        radius : Float,
        filter : ShapeFilter,
        out : ^SegmentQueryInfo
    ) -> ^Shape,
    space_bb_query : proc "c" (
        space : ^Space,
        bb : Bb,
        filter : ShapeFilter,
        func : SpaceBbQueryFunc,
        data : rawptr
    ),
    space_shape_query : proc "c" (
        space : ^Space,
        shape : ^Shape,
        func : SpaceShapeQueryFunc,
        data : rawptr
    ) -> Bool,
    space_each_body : proc "c" (
        space : ^Space,
        func : SpaceBodyIteratorFunc,
        data : rawptr
    ),
    space_each_shape : proc "c" (
        space : ^Space,
        func : SpaceShapeIteratorFunc,
        data : rawptr
    ),
    space_each_constraint : proc "c" (
        space : ^Space,
        func : SpaceConstraintIteratorFunc,
        data : rawptr
    ),
    space_reindex_static : proc "c" (space : ^Space),
    space_reindex_shape : proc "c" (
        space : ^Space,
        shape : ^Shape
    ),
    space_reindex_shapes_for_body : proc "c" (
        space : ^Space,
        body : ^Body
    ),
    space_use_spatial_hash : proc "c" (
        space : ^Space,
        dim : Float,
        count : _c.int
    ),
    space_step : proc "c" (
        space : ^Space,
        dt : Float
    ),
    space_debug_draw : proc "c" (
        space : ^Space,
        options : ^SpaceDebugDrawOptions
    ),
    moment_for_circle : proc "c" (
        m : Float,
        r1 : Float,
        r2 : Float,
        offset : Vect
    ) -> Float,
    area_for_circle : proc "c" (
        r1 : Float,
        r2 : Float
    ) -> Float,
    moment_for_segment : proc "c" (
        m : Float,
        a : Vect,
        b : Vect,
        radius : Float
    ) -> Float,
    area_for_segment : proc "c" (
        a : Vect,
        b : Vect,
        radius : Float
    ) -> Float,
    moment_for_poly : proc "c" (
        m : Float,
        count : _c.int,
        verts : ^Vect,
        offset : Vect,
        radius : Float
    ) -> Float,
    area_for_poly : proc "c" (
        count : _c.int,
        verts : ^Vect,
        radius : Float
    ) -> Float,
    centroid_for_poly : proc "c" (
        count : _c.int,
        verts : ^Vect
    ) -> Vect,
    moment_for_box : proc "c" (
        m : Float,
        width : Float,
        height : Float
    ) -> Float,
    moment_for_box_2 : proc "c" (
        m : Float,
        box : Bb
    ) -> Float,
    convex_hull : proc "c" (
        count : _c.int,
        verts : ^Vect,
        result : ^Vect,
        first : ^_c.int,
        tol : Float
    ) -> _c.int,
    closet_point_on_segment : proc "c" (
        p : Vect,
        a : Vect,
        b : Vect
    ) -> Vect,
}

